# Pricing a contract for difference contract (cfd)
def calculate_leveraged_cfd_price(current_price, contract_price, shares, leverage):
    """
    Calculate the price of a leveraged CFD contract.
    
    Parameters:
    current_price (float): The current price of the underlying asset.
    contract_price (float): The price of the asset at the time of the contract.
    shares (int): The number of shares in the contract.
    leverage (int): The leverage factor.

    Returns:
    float: The price of the leveraged CFD contract.
    """
    return (current_price - contract_price) * shares * leverage

# Example usage:
current_asset_price = 150.00  # Current price of the asset
contract_asset_price = 100.00  # Price of the asset at the time of the contract
number_of_shares = 10  # Number of shares in the contract
leverage_factor = 5  # Leverage of 5 times

leveraged_cfd_price = calculate_leveraged_cfd_price(current_asset_price, contract_asset_price, number_of_shares, leverage_factor)
print(f"The price of the leveraged CFD contract is: {leveraged_cfd_price}")

# Capital required to hold a single stock futures contracts 

import math

def calculate_ssf_price(spot_price, dividends, risk_free_rate, time_to_expiration, leverage):
    """
    Calculate the price of a single stock futures contract with leverage.
    
    Parameters:
    spot_price (float): The current price of the stock.
    dividends (float): The expected dividends during the period until expiration.
    risk_free_rate (float): The annualized risk-free interest rate.
    time_to_expiration (float): The time to expiration in years.
    leverage (int): The leverage factor.

    Returns:
    float: The price of the SSF contract.
    """
    ssf_price = (spot_price - dividends) * math.pow((1 + risk_free_rate), time_to_expiration)
    capital_required = ssf_price / leverage
    return capital_required

# Example usage:
spot_price = 100.00  # Current price of the stock
dividends = 2.00  # Expected dividends
risk_free_rate = 0.05  # Risk-free interest rate (5% per annum)
time_to_expiration = 0.5  # Time to expiration in years (6 months)
leverage = 5  # Leverage of 5 times

ssf_price = calculate_ssf_price(spot_price, dividends, risk_free_rate, time_to_expiration, leverage)
print(f"The capital required to hold the leveraged SSF position is: {ssf_price}")

# Pricing warrants contracts using black Scholes 

def price_warrants(spot_price, strike_price, time_to_expiration, risk_free_rate, volatility, dividends, dilution_factor, leverage):
    """
    Calculate the price of a warrant with time to expiration, dividends, dilution, and leverage.
    
    Parameters:
    spot_price (float): The current price of the stock.
    strike_price (float): The exercise price of the warrant.
    time_to_expiration (float): The time to expiration in years.
    risk_free_rate (float): The risk-free interest rate.
    volatility (float): The volatility of the stock.
    dividends (float): The expected dividends during the period until expiration.
    dilution_factor (float): The factor to account for share dilution.
    leverage (int): The leverage factor.

    Returns:
    float: The estimated price of the warrant.
    """
    # Black-Scholes Merton model adjusted for dividends and dilution
    from scipy.stats import norm
    import numpy as np

    # Adjust spot price for dividends and dilution
    adjusted_spot_price = spot_price - dividends - (spot_price * dilution_factor)

    # Calculate d1 and d2
    d1 = (np.log(adjusted_spot_price / strike_price) + (risk_free_rate + 0.5 * volatility ** 2) * time_to_expiration) / (volatility * np.sqrt(time_to_expiration))
    d2 = d1 - volatility * np.sqrt(time_to_expiration)
    
    # Calculate the price of the warrant
    warrant_price = (adjusted_spot_price * norm.cdf(d1) - strike_price * np.exp(-risk_free_rate * time_to_expiration) * norm.cdf(d2)) / leverage
    
    return warrant_price

# Example usage:
current_stock_price = 100.00  # Current stock price
exercise_price = 120.00  # Exercise price of the warrant
time_to_expiration = 1.0  # Time to expiration in years
risk_free_rate = 0.05  # Risk-free interest rate (5% per annum)
volatility = 0.25  # Volatility of the stock (25% per annum)
expected_dividends = 2.00  # Expected dividends
share_dilution_factor = 0.01  # Share dilution factor (1%)
leverage_factor = 5  # Leverage of 5 times

warrant_price = price_warrants(current_stock_price, exercise_price, time_to_expiration, risk_free_rate, volatility, expected_dividends, share_dilution_factor, leverage_factor)
print(f"The estimated price of the warrant is: {warrant_price}")

# pricing warrants using binomial trees

def price_warrants(spot_price, strike_price, time_to_expiration, risk_free_rate, volatility, dividends, dilution_factor, leverage):
    """
    Calculate the price of a warrant with time to expiration, dividends, dilution, and leverage.
    
    Parameters:
    spot_price (float): The current price of the stock.
    strike_price (float): The exercise price of the warrant.
    time_to_expiration (float): The time to expiration in years.
    risk_free_rate (float): The risk-free interest rate.
    volatility (float): The volatility of the stock.
    dividends (float): The expected dividends during the period until expiration.
    dilution_factor (float): The factor to account for share dilution.
    leverage (int): The leverage factor.

    Returns:
    float: The estimated price of the warrant.
    """
    # Black-Scholes Merton model adjusted for dividends and dilution
    from scipy.stats import norm
    import numpy as np

    # Adjust spot price for dividends and dilution
    adjusted_spot_price = spot_price - dividends - (spot_price * dilution_factor)

    # Calculate d1 and d2
    d1 = (np.log(adjusted_spot_price / strike_price) + (risk_free_rate + 0.5 * volatility ** 2) * time_to_expiration) / (volatility * np.sqrt(time_to_expiration))
    d2 = d1 - volatility * np.sqrt(time_to_expiration)
    
    # Calculate the price of the warrant
    warrant_price = (adjusted_spot_price * norm.cdf(d1) - strike_price * np.exp(-risk_free_rate * time_to_expiration) * norm.cdf(d2)) / leverage
    
    return warrant_price

# Example usage:
current_stock_price = 100.00  # Current stock price
exercise_price = 120.00  # Exercise price of the warrant
time_to_expiration = 1.0  # Time to expiration in years
risk_free_rate = 0.05  # Risk-free interest rate (5% per annum)
volatility = 0.25  # Volatility of the stock (25% per annum)
expected_dividends = 2.00  # Expected dividends
share_dilution_factor = 0.01  # Share dilution factor (1%)
leverage_factor = 5  # Leverage of 5 times

warrant_price = price_warrants(current_stock_price, exercise_price, time_to_expiration, risk_free_rate, volatility, expected_dividends, share_dilution_factor, leverage_factor)
print(f"The estimated price of the warrant is: {warrant_price}") 

# Risk neutral probabilities binomial tree pricing model

import numpy as np

def calculate_risk_neutral_probabilities(up_factor, down_factor, risk_free_rate, time_step):
    """
    Calculate risk-neutral probabilities for a binomial tree model.
    
    Parameters:
    up_factor (float): The factor by which the price goes up in each step.
    down_factor (float): The factor by which the price goes down in each step.
    risk_free_rate (float): The annual risk-free interest rate.
    time_step (float): The time step in years.

    Returns:
    float: The risk-neutral probability of an up move.
    float: The risk-neutral probability of a down move.
    """
    # Calculate the risk-free growth factor
    risk_free_growth = np.exp(risk_free_rate * time_step)
    
    # Calculate the risk-neutral probabilities
    p_up = (risk_free_growth - down_factor) / (up_factor - down_factor)
    p_down = 1 - p_up
    
    return p_up, p_down

# Example usage:
up_factor = 1.1  # The price goes up by 10%
down_factor = 0.9  # The price goes down by 10%
risk_free_rate = 0.05  # 5% annual risk-free interest rate
time_step = 1/12  # Monthly time step

p_up, p_down = calculate_risk_neutral_probabilities(up_factor, down_factor, risk_free_rate, time_step)
print(f"Risk-neutral probability of an up move: {p_up}")
print(f"Risk-neutral probability of a down move: {p_down}")

# stochastic equation for a standard Brownian motion 

import numpy as np

def generalized_wiener_process(mu, sigma, dt, steps):
    """
    Simulate a generalized Wiener process.
    
    Parameters:
    mu (float): Drift coefficient.
    sigma (float): Volatility coefficient.
    dt (float): Time increment.
    steps (int): Number of steps to simulate.

    Returns:
    np.array: Simulated values of the process.
    """
    # Initialize the array for the Wiener process
    W = np.zeros(steps+1)
    
    # Generate the increments of a standard Wiener process
    dW = np.random.normal(loc=0.0, scale=np.sqrt(dt), size=steps)
    
    # Calculate the generalized Wiener process
    W[1:] = np.cumsum(mu*dt + sigma*dW)
    
    return W

# Example usage:
mu = 0.05  # Drift coefficient
sigma = 0.2  # Volatility coefficient
dt = 0.01  # Time increment
steps = 1000  # Number of steps

# Generate the process
process = generalized_wiener_process(mu, sigma, dt, steps)

# Print the first 10 values
print(process[:10])

# Ito process



